# -*- coding: utf-8 -*-
"""mo-2-8-0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ie2mVrH0oyWJl5zCNXDWTix10nd8i5Zf

# Лабораторная работа №8

## Рекуррентные нейронные сети для анализа временных рядов

Набор данных для прогнозирования временных рядов, который состоит из среднемесячного числа пятен на солнце, наблюдаемых с января 1749 по август 2017.

Данные в виде csv-файла можно скачать на сайте _Kaggle_: https://www.kaggle.com/robervalt/sunspots/

### Задание 1

Загрузите данные. Изобразите ряд в виде графика. Вычислите основные характеристики временного ряда (сезонность, тренд, автокорреляцию).
"""

import warnings

warnings.filterwarnings('ignore')

from google.colab import drive

drive.mount('/content/drive', force_remount = True)

BASE_DIR = '/content/drive/My Drive/Colab Files/mo-2'

import sys

sys.path.append(BASE_DIR)

import os

DATA_ARCHIVE_NAME = 'sunspots.zip'

LOCAL_DIR_NAME = 'sunspots'

from zipfile import ZipFile

with ZipFile(os.path.join(BASE_DIR, DATA_ARCHIVE_NAME), 'r') as zip_:
    zip_.extractall(LOCAL_DIR_NAME)

DATA_FILE_PATH = 'sunspots/Sunspots.csv'

import pandas as pd

all_df = pd.read_csv(DATA_FILE_PATH, parse_dates = ['Date'], index_col = 'Date')

print(all_df.shape)

all_df.keys()

from statsmodels.tsa.seasonal import seasonal_decompose

additive = seasonal_decompose(all_df['Monthly Mean Total Sunspot Number'],
                              model = 'additive', extrapolate_trend = 'freq')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import rcParams

rcParams['figure.figsize'] = 12, 8

sns.set()
sns.set_palette(sns.color_palette('hls'))

def plot_loss(_history):

    plt.plot(_history.history['loss'])
    plt.plot(_history.history['val_loss'])

    plt.title('Model loss')

    plt.ylabel('Loss')
    plt.xlabel('Epoch')

    plt.legend(['Train', 'Validation'], loc = 'right')

    plt.show()

sns.lineplot(data = additive.observed, label = 'Observed')
sns.lineplot(data = additive.trend, label = 'Trend')
sns.lineplot(data = additive.seasonal, label = 'Seasonal')

plt.xlabel('Date')
plt.ylabel('Monthly Mean Total Sunspot Number')

plt.title('Whole Series with Trend & Seasonality')

plt.show()

"""Рассмотрим подробнее на небольшом промежутке:"""

sns.lineplot(data = additive.observed['1800-01-01':'1810-01-01'], label = 'Observed')
sns.lineplot(data = additive.trend['1800-01-01':'1810-01-01'], label = 'Trend')
sns.lineplot(data = additive.seasonal['1800-01-01':'1810-01-01'], label = 'Seasonal')

plt.xlabel('Date')
plt.ylabel('Monthly Mean Total Sunspot Number')

plt.title('Series for 1800$-$1810 with Trend & Seasonality')

plt.show()

from pandas.plotting import autocorrelation_plot

autocorrelation_plot(all_df.values.tolist())

plt.title('Autocorrelation plot')

plt.show()

"""### Задание 2

Для прогнозирования разделите временной ряд на обучающую, валидационную и контрольную выборки.

Этот шаг будет применён автоматически с помощью индексации массива данных и как параметр `validation_split` метода `model.fit()`.

### Задание 3

Примените модель _ARIMA_ для прогнозирования значений данного временного ряда.
"""

! pip install pmdarima --quiet

from statsmodels.tsa.arima_model import ARIMA

model = ARIMA(all_df['Monthly Mean Total Sunspot Number'].values,
              order = (1, 0, 2))

model_fit = model.fit(disp = 0)

print(model_fit.summary())

residuals = pd.DataFrame(model_fit.resid)

residuals.plot()

plt.show()

residuals.plot(kind = 'kde')

plt.show()

"""### Задание 4

Повторите эксперимент по прогнозированию, реализовав рекуррентную нейронную сеть (с как минимум 2 рекуррентными слоями).

Сначала нужно создать датасет из данных.
"""

TEST_PERIOD = 600

OBSERVATIONS_PER_CYCLE = 11 * 12

TIME_STEPS = OBSERVATIONS_PER_CYCLE

! pip install tensorflow-gpu --pre --quiet

import tensorflow as tf

tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

from tensorflow import keras

import numpy as np
from datetime import timezone

def timeseries_to_dataset(_X_ts, _time_steps):

    samples_n_ = len(_X_ts) - _time_steps

    _X_norm = tf.keras.utils.normalize(_X_ts).squeeze()

    print(_X_ts.shape, _X_norm.shape)

    X_ = np.zeros((samples_n_, _time_steps))
    y_ = np.zeros((samples_n_, ))

    for i in range(samples_n_):

        X_[i] = _X_norm[i:(i + _time_steps)]

        y_[i] = _X_norm[(i + _time_steps)]

    return X_[..., np.newaxis], y_

X_as_ds, y_as_ds = timeseries_to_dataset(
    all_df['Monthly Mean Total Sunspot Number'].values,
    TIME_STEPS)

X, y = X_as_ds[:-TEST_PERIOD], y_as_ds[:-TEST_PERIOD]

X_test, y_test = X_as_ds[-TEST_PERIOD:], y_as_ds[-TEST_PERIOD:]

print(X.shape, X_test.shape, y.shape, y_test.shape)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

model = tf.keras.Sequential()

model.add(LSTM(2, activation = 'relu', return_sequences = True,
               input_shape = X.shape[-2:]))
model.add(LSTM(12, activation = 'relu'))
model.add(Dense(1))

model.compile(optimizer = 'adam',
              loss = 'mse')

model.summary()

history = model.fit(x = X, y = y, epochs = 20, validation_split = 0.15,
                    verbose = 0)

rcParams['figure.figsize'] = 8, 6

plot_loss(history)

results = model.evaluate(X_test, y_test)

print('Test mse:', results)

y_pred = model.predict(X_test[20][np.newaxis, ...])

print(y_pred, y_test[20])

"""### Задание 5

Сравните качество прогноза моделей.

Какой максимальный результат удалось получить на контрольной выборке?
"""